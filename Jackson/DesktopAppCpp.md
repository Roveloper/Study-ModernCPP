# Why use C++ for apps
- 다른 선택지를 선택한다면 아주아주 많다
- 웹을 사용한다면, 간단히 Cross-platform이고, 모바일도 사용 가능한 걸 만들 수 있다.
- 근데 왜 C++?
- Performance Intensive application을 개발한다면?
- low-level에 관련된 기능이 필요하다면?
- C++로 짜여진 라이브러리에 관련된 기능이 필요하다면?
- 이러한 경우에는 C++ GUI Library를 사용하는 것이 타당한 선택이 될 것이다.
- 예를 들어, Game Engine 개발을 한다면, Game Engine의 Core한 기능들은 대부분 C++로 짜여진다. (Unity, Unreal 등) (Unity가 C#  Editor를 이용해서 개발한다고 해서 Game Engine의 Core한 기능들도 C#으로 개발된 것은 아니다)
- 또한 Cross-platform을 지원하는 것이 필요한 경우에는, C#을 사용할 수 없다.

# What's the solution?
- 사실 C++로 GUI 앱을 만드는 건 매우매우 어려움...
- 근데... 왜 어려운가?
- 그 중에 제일 쉬운 방법은 뭔가?
- Cross-platform이면서... 수 많은 rendering api를 지원하는... (directX 9, 10, 11, 12, opengl, vulcan, metal, etc...)
- 그것은 바로.... ImGUI입니다

# [Dear ImGUI](https://github.com/ocornut/imgui)
- immediate mode gui library는 immediate mode graphics library를 이용해서 gui를 만들어내는 것을 의미, 반대로 retained mode가 있음 [IMGUI vs RMGUI](https://collquinn.gitlab.io/portfolio/my-article.html)
- 아 그거 막 토이 프로젝트할 때만 쓰고, 간단한 앱만 만들 수 있는 거 아님? ㄴㄴ 아님
- 아니면 그거 졸라 못생기고 그런거 아님? ㄴㄴ 아니라고요
- 이것은 비디오 게임처럼 말 그대로 어떤 것이든 렌더링 할 수 있음!
- [Hazel](https://hazelengine.com/)도 IMGUI로 만든거임
- master랑 docking branch가 있는데, docking에 유용한 기능이 많으니까, 이걸 사용하는 걸 권장함! 실제로 정확히 무슨 차이가 있는지는 모르겠음

# Immediate mode gui?
- immediate mode gui는 새로운 방식의 graphics API이며, 직관적이고 사용하기가 쉽습니다.
- 예를 들어, 버튼에 관련된 모든 데이터는 해당 버튼을 그리는 함수를 통해 전달됩니다.
- 만약 버튼이 눌린다면, 해당 함수가 true를 return합니다.
- application에 버튼을 추가하는 것은 if문과 if문에 들어가는 기능을 넣는 것처럼 쉽습니다.
- 만약 해당 버튼을 rendering하고 싶지않다면, 할 일은 함수를 호출하지 않는 것입니다.
- UI를 렌더링하는 시스템이 큰 if/else  구조를 통해 특정 UI를 그릴지 그리지 않을 지 정한다는 뜻입니다.
- 사용자는 버튼에 대한 모든 필요한 데이터를 가지고 관리하게 됩니다.
- UI는 순차적으로 동작할 것이며, frame by frame으로 그려낼 것이빈다.
- 그래픽 라이브러리는 프레임 사이의 모델을 저장하지 않으며, 이는 모든 프레임에 버텍스 버퍼는 다시 만들어져야한다는 것을 뜻합니다.
- 이는 Immediate mode gui의 단점입니다.
- 이를 위해서, CPU에 매 순간 동일한 부담을 주게되고, 이는 application을 느리게 할 수 있습니다.
- 다른 단점은 어플리케이션의 위젯들을 실시간으로 이동시키는 것이 쉽지 않다는 것입니다.
- 위젯의 위치와 크기가 위젯 함수에 전달되어야 하며, 따라서 만약 디자이너가 버튼을 이동하거나 크기를 변경하고 싶어한다면, 이는 쉽지않을 것입니다. (코딩에 관련된 내용을 알아야하기 때문에 그렇다는 것 같음)
- 개발자는 해당 버튼을 실시간으로 변경하기 위한 함수 파라미터에 대한 backend를 만들어야할 것입니다. (그나마 개발자 외에도 사용하기 쉽게 만들려면)
- 정리하자면 다음과 같습니다.
- IMGUI (Immediate mode GUI)는 UI를 구성하기 위한 새롭고 쉬운 방법입니다.
- 버튼을 추가하려면, 버튼에서 사용될 내용을 if문 처럼 작성하면 됩니다.
- 이를 통해 UI의 모든 특정들을 구현하고 관리하기 쉽습니다.
- 이 방식은 1인 개발자 또는 소규모 개발자 팀에 적합합니다.
- 왜냐면, IMGUI는 매우 코드 위주의 설계이며, retained API에 비해 동적이지 못하기 때문입니다.
- 대표적인 라이브러리는 `Dear IMGUI`와 `nulkear`가 있습니다.

# Retained UI
- Retained Mode UI (RMGUI)
- 오래 사용되었고, 테스트된 OOP API입니다.
- 많은 개발자들은 이 스타일을 선호합니다. 왜냐면, 이는 모든 객체 지향 엔진 구조와 호환이 좋으며, 구현이 쉽기 때문입니다.
- 버튼에 관련된 모든 데이터는 위젯 객체에 저장됩니다.
- 만약 버튼을 추가하고 싶다면, 위젯 오브젝트를 생성하고, 클릭 함수 바인딩, 버튼 크기, 위치 등을 설정합니다.
- 그 후, 해당 화면에 그려질 객체 리스트에 추가합니다.
- 해당 위젯은 게임 객체처럼 보이며, 리스트에 추가되고, 루프를 돌며, 그려질 것입니다.
- RMGUI의 데이터들은 그래픽 라이브러리에서 관리됩니다.
- 어플리케이션이 실행되고, 모든 것을 로딩하면, 모든 버텍스 버퍼와 모델 데이터를 그래픽 라이브러리에 로딩합니다.
- 만약 사용자가 새로운 프레임을 어플리케이션에 그리고 싶다면, 업데이트가 필요한 객체를 업데이트하기만 합니다.
- 이러한 그래픽 api 스타일의 단점 중 하나는 위젯들이 어플리케이션의 많은 시스템에 연관되어 있다는 것입니다.
- 위젯들은 초기화 되어야하며, 수동으로 위치가 설정되고, 그려질 리스트에 추가되어야하며, UI 컨데이너에 추가되어야 합니다.
- RMGUI에서 위젯을 삭제하려면, IMGUI에서 if문 하나를 지우는 방식과 달리, 존재하는 모든 곳에서 이를 지워줘야한다는 뜻입니다.
- 반면 RMGUI에서는 backend editor를 만드는 것이 아주 쉽습니다.
- 객체들은 내부에 존재하며, 게임 오브젝트처럼 수정할 수 있습니다.
- 모든 데이터가 한 곳에 모여있으므로, 디자이너들을 위한 editor를 만들어주는 것이 쉽습니다.
- 대부분의 개발자가 Object-Oriented System을 사용하기 때문에 RMGUI가 매우 유용하고 이해하기 쉽습니다.
- 개발자는 새로운 객체를 추가하는 것만 하면 됩니다.
- 큰 개발 팀 또는 객체 지향의 UI 시스템을 사용하는 경우 추천합니다.

# How to use Dear IMGUI
- Docking Branch를 일단 clone 뜨자
- examples 폴더에 들어가면 다양한 이름의 example이 존재한다
- 이 example들은 각각의 platform에 대한 boilerplate 코드와 같다. (boilerplate는 여러 곳에서 재사용되며, 반복적으로 비슷한 형태를 띄는 코드를 의미)
- example_win32_directx10은 실제 application window 생성 및 이벤트 처리를 위해 win32 api를 사용하며 directx10을 그래픽 렌더링 api로 사용한다는 의미다. 
- example_glfw_opengl2는 glfw를 이용하여 window 생성 및 이벤트 처리를 하고, opengl2를 이용해서 그래픽 렌더링을 한다는 의미
- backends 폴더도 있는데, 여기에는 위의 예제를 위한 실제 사용 중인 백엔드 파일들이 존재한다. 
- 암튼 아주아주 쉬운 그런 라이브러리라고 생각하자
- 일단 윈도우를 기준으로 한다면, 예제에 있는 솔루션을 열면 만사 해결
- 그리고 솔루션을 최신버전으로 모두 업그레이드 해주자
- glfw_vulkan를 대표로 보자면, 5개의 파일이 있다
- main은 당연히 entry point를 의미하며, 거기에는 glfw를 셋업하는 방법이 포함되어 있다. 다른 예제도 보면 각각의 api를 사용하는 좋은 예시를 아주아주 잘 정리해두었으니, 굳이 IMGUI를 쓰지 않더라도, 각각의 application api의 예시가 궁금하면 봐도 좋을 것 같다.
- 일단 F5를 누르면, 실행이 아주 잘됨ㅋㅋ (Ready to Go 상태로 와있음)
- 그리고 이 branch는 docking branch이므로, 각 메뉴를 윈도우 밖으로 꺼낼 수도 있습니다. (main이나 master branch에서는 불가능)
- 자 그렇다면 이제 우리의 app으로 바꿔봅시다'
- 각각의 주석을 잘 읽어보는 것도 좋습니다. 뭐 폰트를 변경한다거나 그런 내용도 포함되어 있으니까요
- 자 메인 루프 안을 보시면, 각각의 프레임에서 실행되는 imgui 커맨드들이 있습니다.
- 예를 들어 ImGui_ImplVulkan_NewFrame(), ImGui_ImplGlfw_NewFrame(), Imgui::NewFrame() 등이 있죠
- main 루프에서 이 3개의 라인을 실행하고 나면, 대부분의 ui를 렌더링해줍니다.
- 그리고 각자의 코드를 수행하기 위한 부분을 작성합니다 (imgui를 사용해서)
- 만약 당신이 그래픽 렌더링을 위주로 돌아가는 프로그램을 작성한다면, 이는 아주아주 좋은 선택입니다.
- imgui는 imguidemo.cpp이라는 아주 훌륭한 파일이 있습니다.
- 8000줄 정도 되며, 여기에는 당신이 필요한 모든 예제들이 있습니다. (아마도?)
- 아무것도 잘 모를 때는 ImGui::ShowDemoWindow()를 한번 호출해봅시다.
- 그러면 DemoWindow가 짜잔하고 나올 것입니다.
- DemoWindows를 열어보면, 여기에는 정말 다양한 Demo들이 포함되어 있습니다.
- 그리고 거기서 원하는 내용을 찾은 후에, imguidemo.cpp 파일에서 해당 내용을 검색해서 사용할 수 있습니다.
- 예를 들어 dockspace를 검색해보죠, 그러면 거기에는 dock space의 예시가 있습니다.
- 그걸 그대로 복사해서, 내 코드에 추가하는 거죠.
- 그리고 문제가 되는 파라미터를 확인해서 입력해주면 좋을 것 같습니다.
- 그러면 이제 내 프로그램에서 dock space를 사용할 수 있게됩니다!
- 심지어, 만약 종료 후 다시 실행하면...? 이 레이아웃이 그대로 저장되어 있습니다 (imgui.ini에 저장됨)
- 가장 큰 장점은... 만약 하다가 내 application api와 graphic api가 마음에 들지 않는다면, 사용하는 UI 관련 코드만 그대로 복사해서 다른 프로젝트에서 열어서 UI 부분을 내 코드로 교체한다면..? 짜잔, 다른 프로젝트에서도 그대로~~ 사용이 가능합니다.
- 아무튼 코드 몇줄 안짜고, 앱을 만들 수 있으니까~~~ 잘 써보도록 합시다.